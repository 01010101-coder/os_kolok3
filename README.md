# Практические примеры поведенческих паттернов проектирования

В данном репозитории представлены примеры реализации трех классических поведенческих паттернов проектирования на языке C++ с учетом многопоточности.

## Структура проекта

```
project/
├── README.md
├── src/
│   ├── command_example.cpp    # Пример паттерна Command
│   ├── strategy_example.cpp   # Пример паттерна Strategy
│   └── template_method_example.cpp  # Пример паттерна Template Method
└── Makefile
```

## Описание паттернов

### 1. Паттерн Command (Команда)

**Суть паттерна**  
Паттерн Command инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Ключевые аспекты**  
- **Инкапсуляция запроса**: Каждая команда представляет собой отдельный объект с методом `execute()`
- **Отмена операций**: Команды могут реализовывать метод `undo()` для отмены выполненных действий
- **Очереди команд**: Команды можно ставить в очередь и выполнять асинхронно
- **Многопоточность**: В примере реализована потокобезопасная очередь команд с использованием мьютексов и условных переменных

**Примеры применения**  
- Системы с поддержкой Undo/Redo
- Очереди задач в многопоточных приложениях
- Макрокоманды (составные команды)

### 2. Паттерн Strategy (Стратегия)

**Суть паттерна**  
Паттерн Strategy определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения программы.

**Ключевые аспекты**  
- **Инкапсуляция алгоритмов**: Каждый алгоритм реализован в отдельном классе
- **Взаимозаменяемость**: Стратегии можно менять во время выполнения
- **Изоляция изменений**: Изменение одного алгоритма не влияет на другие
- **Многопоточность**: Каждый поток может использовать свою стратегию независимо

**Примеры применения**  
- Различные алгоритмы сортировки
- Стратегии сжатия данных
- Алгоритмы шифрования

### 3. Паттерн Template Method (Шаблонный метод)

**Суть паттерна**  
Паттерн Template Method определяет скелет алгоритма, откладывая некоторые шаги на подклассы. Это позволяет подклассам переопределять определенные шаги алгоритма, не меняя его структуру.

**Ключевые аспекты**  
- **Скелет алгоритма**: Базовый класс определяет последовательность шагов
- **Переопределение шагов**: Подклассы могут переопределять отдельные шаги
- **Контроль процесса**: Базовый класс контролирует общий поток выполнения
- **Многопоточность**: Отдельные шаги алгоритма могут выполняться параллельно

**Примеры применения**  
- Обработка различных форматов файлов
- Игровые циклы
- Фреймворки для тестирования

## Многопоточность в паттернах

### Общие принципы

1. **Синхронизация доступа**  
   - Использование мьютексов для защиты общих ресурсов
   - Применение условных переменных для координации потоков
   - Атомарные операции для простых случаев

2. **Изоляция данных**  
   - Каждый поток работает со своей копией данных
   - Минимизация общего состояния
   - Использование локальных переменных

3. **Асинхронное выполнение**  
   - Очереди задач для асинхронного выполнения
   - Callback-функции для обработки результатов
   - Future/Promise для получения результатов

### Специфика для каждого паттерна

**Command**  
- Потокобезопасная очередь команд
- Синхронизированная история команд для Undo/Redo
- Асинхронное выполнение команд

**Strategy**  
- Независимое выполнение стратегий в разных потоках
- Потокобезопасная замена стратегий
- Кэширование результатов стратегий

**Template Method**  
- Параллельное выполнение отдельных шагов
- Синхронизация на уровне шагов
- Асинхронное выполнение длительных операций

## Сборка и запуск

Для сборки проекта используйте команду:
```bash
make
```

Для запуска примеров:
```bash
./command_example
./strategy_example
./template_method_example
```

Для очистки скомпилированных файлов:
```bash
make clean
```

## Требования

- Компилятор C++ с поддержкой C++17
- Make
- Поддержка многопоточности в стандартной библиотеке C++
# os_kolok3
