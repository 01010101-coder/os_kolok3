# Практические примеры поведенческих паттернов проектирования

В данном репозитории представлены примеры реализации трех классических поведенческих паттернов проектирования на языке C++ с учетом многопоточности.

## Структура проекта

your-project/
├── README.md
├── src/
│   ├── command_example.cpp
│   ├── strategy_example.cpp
│   └── template_method_example.cpp
└── Makefile
## Описание паттернов

### 1. Паттерн Command (Команда)

**Суть паттерна**  
Паттерн Command инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Ключевые аспекты**  
- **Инкапсуляция запроса**: Каждая команда представляет собой отдельный объект с методом `execute()`
- **Отмена операций**: Команды могут реализовывать метод `undo()` для отмены выполненных действий
- **Очереди команд**: Команды можно ставить в очередь и выполнять асинхронно
- **Многопоточность**: В примере реализована потокобезопасная очередь команд с использованием мьютексов и условных переменных

**Примеры применения**  
- Системы с поддержкой Undo/Redo
- Очереди задач в многопоточных приложениях
- Макрокоманды (составные команды)

### 2. Паттерн Strategy (Стратегия)

**Суть паттерна**  
Паттерн Strategy определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения программы.

**Ключевые аспекты**  
- **Инкапсуляция алгоритмов**: Каждый алгоритм реализован в отдельном классе
- **Взаимозаменяемость**: Стратегии можно менять во время выполнения
- **Изоляция изменений**: Изменение одного алгоритма не влияет на другие
- **Многопоточность**: Каждый поток может использовать свою стратегию независимо

**Примеры применения**  
- Различные алгоритмы сортировки
- Стратегии сжатия данных
- Алгоритмы шифрования

### 3. Паттерн Template Method (Шаблонный метод)

**Суть паттерна**  
Паттерн Template Method определяет скелет алгоритма, откладывая некоторые шаги на подклассы. Это позволяет подклассам переопределять определенные шаги алгоритма, не меняя его структуру.

**Ключевые аспекты**  
- **Скелет алгоритма**: Базовый класс определяет последовательность шагов
- **Переопределение шагов**: Подклассы могут переопределять отдельные шаги
- **Контроль процесса**: Базовый класс контролирует общий поток выполнения
- **Многопоточность**: Отдельные шаги алгоритма могут выполняться параллельно

**Примеры применения**  
- Обработка различных форматов файлов
- Игровые циклы
- Фреймворки для тестирования

## Многопоточность в паттернах

### Общие принципы

1. **Синхронизация доступа**  
   - Использование мьютексов для защиты общих ресурсов
   - Применение условных переменных для координации потоков
   - Атомарные операции для простых случаев

2. **Изоляция данных**  
   - Каждый поток работает со своей копией данных
   - Минимизация общего состояния
   - Использование локальных переменных

3. **Асинхронное выполнение**  
   - Очереди задач для асинхронного выполнения
   - Callback-функции для обработки результатов
   - Future/Promise для получения результатов

### Специфика для каждого паттерна

**Command**  
- Потокобезопасная очередь команд
- Синхронизированная история команд для Undo/Redo
- Асинхронное выполнение команд

**Strategy**  
- Независимое выполнение стратегий в разных потоках
- Потокобезопасная замена стратегий
- Кэширование результатов стратегий

**Template Method**  
- Параллельное выполнение отдельных шагов
- Синхронизация на уровне шагов
- Асинхронное выполнение длительных операций

## Сборка и запуск

Для сборки проекта используйте команду:
make


Для запуска примеров:
./command_example
./strategy_example
./template_method_example


Для очистки скомпилированных файлов:
make clean


## Требования

- Компилятор C++ с поддержкой C++17
- Make
- Поддержка многопоточности в стандартной библиотеке C++

## Ответы на вопросы

### 1. Поведенческие паттерны проектирования

#### Паттерн Command (Команда)

**Определение**  
Паттерн Command инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Проблемы и решения**  
1. **GUI-меню**  
   - *Проблема*: Каждый пункт меню требует своей обработки клика
   - *Решение*: Каждый пункт меню - объект Command с методом execute()
   - *Инкапсуляция*: Детали выполнения скрыты в объекте команды
   - *Разделяй и властвуй*: Отделены создание, очередь и выполнение команд
   - *Ортогональность*: Новые команды добавляются без изменения системы

2. **Undo/Redo**  
   - *Проблема*: Необходимость отмены и повтора действий
   - *Решение*: Хранение истории команд и вызов undo()/redo()
   - *Инкапсуляция*: Логика отмены скрыта в команде
   - *Разделяй и властвуй*: Отделены выполнение и отмена
   - *Ортогональность*: Каждая команда независима

3. **Макрокоманды**  
   - *Проблема*: Выполнение цепочки действий
   - *Решение*: Композиция команд в макрокоманду
   - *Инкапсуляция*: Детали последовательности скрыты
   - *Разделяй и властвуй*: Каждая команда независима
   - *Ортогональность*: Команды можно комбинировать

**Многопоточность**  
- Команды можно ставить в потокобезопасную очередь
- Выполнение команд в отдельном потоке
- Синхронизация через мьютексы и условные переменные
- Возможность параллельного выполнения независимых команд

#### Паттерн Strategy (Стратегия)

**Определение**  
Паттерн Strategy определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения программы.

**Проблемы и решения**  
1. **Сортировка**  
   - *Проблема*: Разные алгоритмы для разных данных
   - *Решение*: Выбор QuickSort, MergeSort или HeapSort
   - *Инкапсуляция*: Алгоритм скрыт в стратегии
   - *Разделяй и властвуй*: Отделены выбор и выполнение
   - *Ортогональность*: Стратегии независимы

2. **Шифрование**  
   - *Проблема*: Разные уровни безопасности
   - *Решение*: Выбор AES, RSA или DES
   - *Инкапсуляция*: Детали шифрования скрыты
   - *Разделяй и властвуй*: Отделены выбор и применение
   - *Ортогональность*: Стратегии не влияют друг на друга

3. **Компрессия**  
   - *Проблема*: Разные форматы сжатия
   - *Решение*: Выбор ZIP, GZIP или LZW
   - *Инкапсуляция*: Детали сжатия скрыты
   - *Разделяй и властвуй*: Отделены выбор и применение
   - *Ортогональность*: Стратегии независимы

**Многопоточность**  
- Каждый поток может использовать свою стратегию
- Стратегии могут быть потокобезопасными
- Возможность параллельного выполнения
- Кэширование результатов стратегий

#### Паттерн Template Method (Шаблонный метод)

**Определение**  
Паттерн Template Method определяет скелет алгоритма, откладывая некоторые шаги на подклассы. Это позволяет подклассам переопределять определенные шаги алгоритма, не меняя его структуру.

**Проблемы и решения**  
1. **Парсинг файлов**  
   - *Проблема*: Разные форматы (CSV, XML, JSON)
   - *Решение*: Общий метод parse() с переопределяемыми шагами
   - *Инкапсуляция*: Скелет алгоритма в одном месте
   - *Разделяй и властвуй*: Отделены общая структура и детали
   - *Ортогональность*: Новые форматы добавляются легко

2. **Игровой цикл**  
   - *Проблема*: Повторяющийся цикл обновления
   - *Решение*: Общий метод run() с хуками
   - *Инкапсуляция*: Цикл скрыт в базовом классе
   - *Разделяй и властвуй*: Отделены цикл и действия
   - *Ортогональность*: Новые игры добавляются легко

3. **Тестовые фреймворки**  
   - *Проблема*: Однотипная структура тестов
   - *Решение*: Общий метод execute() с шагами
   - *Инкапсуляция*: Структура теста скрыта
   - *Разделяй и властвуй*: Отделены структура и тесты
   - *Ортогональность*: Новые тесты добавляются легко

**Многопоточность**  
- Отдельные шаги могут выполняться параллельно
- Синхронизация на уровне шагов
- Возможность асинхронного выполнения
- Потокобезопасность на уровне шагов

### 2. Архитектура ПО и многопоточность

**Что такое архитектура ПО**  
Архитектура ПО - это высокоуровневая структура системы, определяющая:
- Компоненты системы и их взаимодействие
- Принципы проектирования и организации
- Распределение ответственности
- Технические решения и ограничения

**Влияние многопоточности на архитектуру**  
1. **Слои конкуренции**  
   - Выделение слоев с разным уровнем параллелизма
   - Разделение на UI, worker и I/O потоки
   - Четкое определение границ между слоями
   - Синхронизация на границах слоев

2. **Асинхронная коммуникация**  
   - Переход от синхронных к асинхронным вызовам
   - Использование очередей сообщений
   - Паттерн publish/subscribe
   - Минимизация блокировок

3. **Управление состоянием**  
   - Минимизация общего состояния
   - Использование immutable объектов
   - Транзакционность операций
   - Lock-free структуры данных

4. **Масштабируемость**  
   - Горизонтальное разделение работы
   - Thread pool и actor model
   - Reactive подходы
   - Балансировка нагрузки

5. **Тестируемость**  
   - Возможность тестирования в однопоточном режиме
   - Изоляция многопоточного кода
   - Детерминированное поведение
   - Нагрузочное тестирование
